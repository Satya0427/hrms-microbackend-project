import { Request, Response } from 'express';
import { async_error_handler } from '../../common/utils/async_error_handler';
import { apiResponse, apiDataResponse } from '../../common/utils/api_response';
import { safeValidate } from '../../common/utils/validation_middleware';
import {
  createEmployeeProfileSchema
} from './onboarding.validator';
import mongoose, { Types } from 'mongoose';
import { EMPLOYEE_PROFILE_MODEL } from '../../common/schemas/Employees/employee_onboarding.schema';
import { ORGANIZATION_MODEL } from '../../common/schemas/Organizations/organization.schema';
import { getGridFSBucket } from "../../config/db_connections/gridfs";
import { EMPLOYEE_DOCUMENT_MODEL } from '../../common/schemas/Employees/employee_documents.schema';
import { EMPLOYEE_COMPENSATION_MODEL } from '../../common/schemas/Employees/employee_compensiation.schema';
import { encryptPassword } from '../../common/utils/common';
interface CustomRequest extends Request {
  user?: {
    user_id: string;
    session_id: string;
    organization_id: string;
  };
}

//#region Employee Details
// ==================== EMPLOYEE_ID API CALL ===================
const getAutoGeneratedEmpIdAPIHandler = async_error_handler(async (req: CustomRequest, res: Response) => {
  const organization_id = req?.user?.organization_id
  if (!organization_id) {
    res.status(400).json(apiResponse(400, 'Organization Id Required'));
    return;
  }
  const organization = await ORGANIZATION_MODEL.findById(organization_id)
    .select("organization.organization_code")
    .lean();

  if (!organization) {
    throw new Error("Organization not found");
  }

  const orgCode = organization.organization.organization_code;
  const lastEmployee = await EMPLOYEE_PROFILE_MODEL.aggregate([
    {
      $match: {
        organization_id: new mongoose.Types.ObjectId(organization_id),
        "job_details.employee_id": {
          $regex: `^${orgCode}`,   // ✅ anchor prefix
          $options: "i"
        }
      }
    },
    {
      $project: {
        numeric_part: {
          $toInt: {
            $substrBytes: [
              "$job_details.employee_id", // ✅ correct path
              orgCode.length,              // start after prefix
              {
                $subtract: [
                  { $strLenBytes: "$job_details.employee_id" },
                  orgCode.length
                ]
              }
            ]
          }
        }
      }
    },
    { $sort: { numeric_part: -1 } },
    { $limit: 1 }
  ]);

  /* ================= GENERATE NEXT ID ================= */
  const nextNumber = lastEmployee.length > 0 ? lastEmployee[0].numeric_part + 1 : 1;
  const emp_code = orgCode + String(nextNumber).padStart(5, "0");

  /* ================= RESPONSE ================= */
  res.status(200).json(apiDataResponse(200, 'Success', { emp_code: `${orgCode}${String(nextNumber).padStart(5, "0")}` }))
})

const createEmployeeOnboardingAPIHandler = async_error_handler(async (req: CustomRequest, res: Response) => {
  const organization_id = req?.user?.organization_id;
  if (!organization_id) {
    res.status(400).json(apiResponse(400, "Organization Id Required"));
    return;
  }
  /* ================= 1. PARSE FORM DATA ================= */
  const personal_details = JSON.parse(req.body.personal_details);
  const job_details = JSON.parse(req.body.job_details);
  const emergency_contact = req.body.emergency_contact ? JSON.parse(req.body.emergency_contact) : undefined;
  const employee_uuid = req.body.employee_uuid || null;

  /* ================= 2. ZOD VALIDATION ================= */
  const validatedData = safeValidate(createEmployeeProfileSchema, {
    body: {
      personal_details,
      job_details,
      emergency_contact
    }
  });
  if (!validatedData.success) {
    res.status(400).json(apiDataResponse(400, "Validation failed", validatedData.errors?.[0]?.message));
    return;
  }

  /* ================= 3. CHECK DUPLICATE EMPLOYEE (CREATE ONLY) ================= */
  if (!employee_uuid) {
    const existingEmployee = await EMPLOYEE_PROFILE_MODEL.findOne({
      organization_id,
      "job_details.employee_id": job_details.employee_id,
      is_deleted: false
    });

    if (existingEmployee) {
      res.status(409).json(apiResponse(400, "Employee ID already exists in this organization"));
      return;
    }
  }

  /* ================= 4. UPLOAD IMAGE TO GRIDFS ================= */
  let profileImageId: Types.ObjectId | undefined;

  if (req.file) {
    const bucket = getGridFSBucket();
    const existingFile = await bucket.find({
      "metadata.type": "EMPLOYEE_PROFILE_IMAGE",
      "metadata.employee_id": job_details.employee_id
    }).toArray();
    for (const file of existingFile) {
      await bucket.delete(file._id);
    }
    const uploadStream = bucket.openUploadStream(req.file.originalname, {
      metadata: {
        contentType: req.file.mimetype,
        type: "EMPLOYEE_PROFILE_IMAGE",
        version: Date.now(),
        employee_id: job_details.employee_id,
        is_latest: true
      }
    });
    uploadStream.end(req.file.buffer);
    await new Promise<void>((resolve, reject) => {
      uploadStream.on("finish", resolve);
      uploadStream.on("error", reject);
    });
    profileImageId = uploadStream.id;
  }

  // PASSWORD (ONLY IF PRESENT)
  if (personal_details.password) {
    personal_details.password = await encryptPassword(personal_details.password);
  }
  /* ================= 5. CREATE / UPDATE EMPLOYEE ================= */
  const employeePayload = {
    organization_id,
    personal_details: {
      ...personal_details,
      ...(profileImageId && { profileImage: profileImageId })
    },
    job_details,
    emergency_contact,
    updated_by: new Types.ObjectId(req.user?.user_id)
  };
  let employee;
  if (employee_uuid) {
    /* ================= UPDATE EXISTING EMPLOYEE ================= */
    employee = await EMPLOYEE_PROFILE_MODEL.findOneAndUpdate(
      {
        _id: new Types.ObjectId(employee_uuid),
        organization_id
      },
      {
        $set: {
          ...employeePayload,
          updated_by: new Types.ObjectId(req.user?.user_id)
        }
      },
      {
        new: true,
        runValidators: true
      }
    );
    if (!employee) {
      res.status(400).json(apiResponse(400, "Employee not found"));
      return
    }
  } else {
    /* ================= CREATE NEW EMPLOYEE ================= */
    employee = await EMPLOYEE_PROFILE_MODEL.create({
      ...employeePayload,
      organization_id,
      created_by: new Types.ObjectId(req.user?.user_id)
    });
  }

  /* ================= 6. RESPONSE ================= */
  const sts = 200;
  const msg = employee_uuid ? "Employee profile updated successfully" : "Employee profile created successfully";
  res.status(200).json(apiDataResponse(sts, msg, employee));
}
);

//  ==================== LIST EMPLOYMENT PROFILES ====================
const getEmployeeAPIHandler = async_error_handler(async (req: CustomRequest, res: Response) => {

  let {
    page = 1,
    limit = 10,
    search_key = "",
    id = ''
  } = req.body;
  const organization_id = req.user?.organization_id;

  if (!organization_id) {
    res.status(400).json(apiResponse(400, "Organization Id required"));
    return
  };

  /* ================= QUERY PARAMS ================= */

  page = Number(page || 1);
  limit = Number(limit || 10);
  const skip = (page - 1) * limit;


  const match: any = {
    organization_id: new Types.ObjectId(organization_id),
    is_deleted: false
  };

  if (search_key && !id) {
    match.$or = [
      { "personal_details.firstName": { $regex: search_key, $options: "i" } },
      { "personal_details.lastName": { $regex: search_key, $options: "i" } },
      { "job_details.employee_id": { $regex: search_key, $options: "i" } }
    ];
  }
  if (id) {
    if (!Types.ObjectId.isValid(id)) {
      res.status(400).json(apiResponse(400, "Invalid employee id"));
      return;
    }
    match._id = new Types.ObjectId(id);
  }

  const pipeline: any = [
    { $match: match },
    {
      $lookup: {
        from: 'departments',
        localField: 'job_details.department_id',
        foreignField: '_id',
        as: 'department'
      }
    },
    {
      $lookup: {
        from: 'designations',
        localField: 'job_details.designation_id',
        foreignField: '_id',
        as: 'designation'
      }
    },
    { $unwind: { path: '$department', preserveNullAndEmptyArrays: true } },
    { $unwind: { path: '$designation', preserveNullAndEmptyArrays: true } },
    {
      $addFields: {
        'job_details.department_name': '$department.department_name',
        'job_details.designation_name': '$designation.designation_name'
      }
    },
    {
      $project: {
        department: 0,
        designation: 0
      }
    }
  ];

  if (!id) {
    pipeline.push(
      { $sort: { createdAt: -1 } as const },
      { $skip: skip },
      { $limit: limit }
    )
  }

  const [employees, total] = await Promise.all([
    EMPLOYEE_PROFILE_MODEL.aggregate(pipeline),
    EMPLOYEE_PROFILE_MODEL.countDocuments(match)
  ]);

  const employeesWithImage = employees.map(emp => ({
    ...emp,
    profileImageUrl: emp.personal_details.profileImage ? `/common/get_image/${emp.personal_details.profileImage}` : null
  }));
  /* ================= RESPONSE ================= */
  const res_data: any = {
    data: employeesWithImage,
  }
  if (!id) {
    res_data.pagination = {
      page,
      limit,
      total,
      totalPages: Math.ceil(total / limit)
    }
  }
  res.status(200).json(apiDataResponse(200, 'Success', res_data));

});
//#endregion


//#region Employee Documents
// ==================== SAVE DOCUMENT API CALL ===================
const saveEmployeeDocumentAPIHandler = async_error_handler(async (req: CustomRequest, res: Response) => {

  /* ================= VALIDATIONS ================= */
  if (!req.file) {
    res.status(400).json(apiResponse(400, "Document file is required"));
    return
  }
  let { documentType, formValues, employee_uuid } = req.body;
  const organization_id = req?.user?.organization_id;
  const created_by = req?.user?.user_id;
  if (!documentType || !formValues || !employee_uuid) {
    res.status(400).json(apiResponse(400, "Missing required fields"));
    return
  }
  const parsedFormValues = JSON.parse(formValues);

  /* ================= GRIDFS UPLOAD (SAME STYLE) ================= */
  let fileId: Types.ObjectId | undefined;
  if (req.file) {
    const bucket = getGridFSBucket();
    const uploadStream = bucket.openUploadStream(
      req.file.originalname,
      {
        metadata: {
          contentType: req.file.mimetype,
          type: documentType,
          employee_id: employee_uuid
        }
      }
    );
    uploadStream.end(req.file.buffer);
    await new Promise<void>((resolve, reject) => {
      uploadStream.on("finish", () => {
        resolve();
      });
      uploadStream.on("error", (err) => {
        reject(err);
      });
    });
    fileId = uploadStream.id;
  }

  /* ================= SAVE METADATA ================= */
  const documentRecord = await EMPLOYEE_DOCUMENT_MODEL.create({
    organization_id: organization_id,
    employee_uuid: employee_uuid,
    document_type: documentType,
    file_id: fileId,
    form_values: {
      docName: parsedFormValues.docName,
      docId: parsedFormValues.docId,
      dob: parsedFormValues.dob,
      issueDate: parsedFormValues.issueDate,
      expiryDate: parsedFormValues.expiryDate
    },
    status: "ACTIVE",
    is_verified: false,
    created_by: created_by
  });
  res.status(200).json(apiDataResponse(200, "Document saved successfully", documentRecord));
});

// ==================== GET DOCUMENT DETAILS ===================
const getEmployeeDocumentsAPIHandler = async_error_handler(async (req: CustomRequest, res: Response) => {

  const { employee_uuid, documentType } = req.body;
  const organization_id = req?.user?.organization_id;
  /* ================= VALIDATIONS ================= */
  if (!employee_uuid) {
    res.status(400).json(apiResponse(400, "Employee UUID is required"));
    return;
  }

  /* ================= QUERY BUILD ================= */
  const query: any = {
    employee_uuid,
    organization_id,
    status: { $ne: "DELETED" }
  };
  // Apply documentType filter ONLY if provided
  if (Array.isArray(documentType) && documentType.length > 0) {
    query.document_type = { $in: documentType };
  }

  /* ================= FETCH ================= */
  const documents = await EMPLOYEE_DOCUMENT_MODEL.find(query)
    .sort({ createdAt: -1 })
    .lean();

  /* ================= RESPONSE ================= */
  res.status(200).json(apiDataResponse(200, "Employee documents fetched successfully", documents));
});
//#region


//#region Compensiation
// ==================== SAVE EMPLOYEE COMPENSATION ===================
const saveEmployeeCompensationAPIHandler = async_error_handler(async (req: CustomRequest, res: Response) => {
  const {
    employee_uuid, pay_structure, currency = "INR", basic, hra, special_allowance, allowances = [],
    deductions = [], gross_salary, total_deductions, net_salary, ctc, effective_from,
  } = req.body;
  const organization_id = req.user?.organization_id;
  if (!organization_id) {
    res.status(400).json(apiResponse(400, "Organization Id Required"));
    return;
  }
  if (!employee_uuid) {
    res.status(400).json(apiResponse(400, "Employee UUID is required"));
    return;
  }

  /* ================= 2. CHECK EMPLOYEE EXISTS ================= */
  const employeeExists = await EMPLOYEE_PROFILE_MODEL.findOne({
    _id: new Types.ObjectId(employee_uuid),
    organization_id,
    is_deleted: false,
  });

  if (!employeeExists) {
    res.status(404).json(apiResponse(404, "Employee not found"));
    return;
  }

  /* ================= 3. DEACTIVATE OLD COMPENSATION ================= */
  await EMPLOYEE_COMPENSATION_MODEL.updateMany(
    {
      employee_uuid: new Types.ObjectId(employee_uuid),
      organization_id,
      is_active: true,
    },
    {
      $set: {
        is_active: false,
        effective_to: new Date(),
        updated_by: new Types.ObjectId(req.user?.user_id),
      },
    }
  );
  const payload = {
    organization_id,
    employee_uuid: new Types.ObjectId(employee_uuid),
    pay_structure,
    currency,
    basic,
    hra,
    special_allowance,
    allowances,
    deductions,
    gross_salary,
    total_deductions,
    net_salary,
    ctc,
    effective_from: new Date(effective_from),
    is_active: true,
    created_by: new Types.ObjectId(req.user?.user_id),
  };
  /* ================= 4. CREATE NEW COMPENSATION ================= */
  const newCompensation = await EMPLOYEE_COMPENSATION_MODEL.create(payload);

  /* ================= 5. RESPONSE ================= */
  res.status(200).json(apiDataResponse(200, "Employee compensation saved successfully", newCompensation));
}
);

// ==================== GET EMPLOYEE COMPENSATION ====================
const getEmployeeCompensationAPIHandler = async_error_handler(async (req: CustomRequest, res: Response) => {

  const { employee_uuid } = req.params;
  const organization_id = req.user?.organization_id;

  if (!organization_id) {
    res.status(400).json(apiResponse(400, "Organization Id Required"));
    return
  }

  if (!employee_uuid) {
    res.status(400).json(apiResponse(400, "Employee UUID is required"));
    return
  }

  /* ================= 1. VALIDATE OBJECT ID ================= */
  if (!Types.ObjectId.isValid(employee_uuid)) {
    res.status(400).json(apiResponse(400, "Invalid Employee UUID format"));
    return
  }

  const employeeObjectId = new Types.ObjectId(employee_uuid);

  /* ================= 2. CHECK EMPLOYEE EXISTS ================= */
  const employeeExists = await EMPLOYEE_PROFILE_MODEL.findOne({
    _id: employeeObjectId,
    organization_id,
    is_deleted: false,
  }).lean();

  if (!employeeExists) {
    res.status(404).json(apiResponse(404, "Employee not found"));
    return
  }

  /* ================= 3. FETCH ACTIVE COMPENSATION ================= */
  const compensation = await EMPLOYEE_COMPENSATION_MODEL.findOne({
    employee_uuid: employeeObjectId,
    organization_id,
    is_active: true,
  })
    .sort({ effective_from: -1 })
    .lean();

  if (!compensation) {
    res.status(404).json(apiResponse(404, "Employee compensation not found"));
    return
  }

  /* ================= 4. RESPONSE ================= */
  res.status(200).json(apiDataResponse(200, "Employee compensation fetched successfully", compensation));
}
);


export {
  createEmployeeOnboardingAPIHandler,
  getEmployeeAPIHandler,
  getAutoGeneratedEmpIdAPIHandler,
  saveEmployeeDocumentAPIHandler,
  getEmployeeDocumentsAPIHandler,
  saveEmployeeCompensationAPIHandler,
  getEmployeeCompensationAPIHandler
};